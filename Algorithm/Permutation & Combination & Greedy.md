# 완전 검색 & 그리디

* 반복을 이용한 선택정렬 : 가장 작은애 맨 앞으로 보내는 작업 반복


### 재귀 vs 반복

* 일반적으로 재귀가 반복보다 더 많은 메모리와 연산을 필요로 함.
* 입력 n 값이 커질수록 재귀 알고리즘은 반복에 비해 비효율적일 수 있음.



|                |        재귀        |     반복      |
| :------------: | :----------------: | :-----------: |
|      종료      | 재귀 함수에서 종료 |  반복문 종료  |
|   수행 시간    |        느림        |     빠름      |
|  메모리 공간   |     많이 사용      |   적게 사용   |
| 소스 코드 길이 |     짧고 간결      |     길다      |
| 소스 코드 형태 |    if ... else     |  for, while   |
|  무한 반복시   |  스택 오버플로우   | CPU 반복 점유 |





## 순열(Permutation)

>서로 다른 것들 중 몇 개를 뽑아서 한 줄로 나열하는 것.
>
>서로 다른 n개중 r개를 택하는 것

$$
nPr = n * (n-1)*(n-2)*...*(n-r+1)
$$



* 최소한의 변경

```python
def f(n, k):
    if n == k:
        print(a)
    else:
        for j in range(n, k):
            a[n], a[j] = a[j], a[n]
            f(n+1, k)
            a[n], a[j] = a[j], a[n]


a = [1, 2, 3]
f(0, 3)
```



* 재귀, index기준 사전순 

```python
def f(n, k, m):			#mPk
    if n == k:
        print(p)
    else:
        for i in range(m):
            if used[i] == 0:
                used[i] = 1
                p[n] = a[i]
                f(n+1, k, m)
                used[i] = 0
    return
                
a = [1, 2, 3]
p = [0]*k
used = [0]*m
f(0, 3)
```





## 부분집합

### 바이너리 카운팅(Binary Counting)

* 원소 수에 해당하는 N개의 비트열을 이용한다.

* n번째 비트값이 1이면 n번째 원소가 포함되었음을 의미함.

  







## 조합(Combination)

> 서로 다른 n개의 원소 중 r개를 순서 없이 골라낸 것을 조합

* 수식

$$
nCr = n!/(n-r)!r!
$$

* 재귀적 표현
  $$
  nCr = n-1Cr-1 + n-1Cr
  $$
  

```python
'''반복으로 조합만들기'''
n = 10	# 10개 숫자 중
r = 3	# 3개 고르기

for i in range(n-r+1):
    for j in range(i+1, n-(r-1)+1):
        for k in range(j+1 ,n):
            print(i, j, k)
            
          
        
'''재귀'''        
        
def nCr(n, r, s):
    if r == 0:
        print(comb)
    else:
        for i in range(s, n-r+1):
            comb[r-1] = A[i]
            nCr(n,r-1,i+1)


n = 5
r = 4
comb = [0]*3
A = [i for i in range(1, n+1)]
nCr(n, r, 0)



```







## 그리디

> 순간의 최적해를 찾아가는 방법
>
> 순간적으로는 최적해를 구할 수 있지만, 최종답이 최적이라고 볼 수 없음.

### 거스름돈 최적해 구하기

* 400 o vs 400 x
* 거스름돈 : 800

| 500, 100, 50, 10 | 500, 400, 100, 50, 10 |
| :--------------: | :-------------------: |
|  1, 3, 0, 0 개   |    1, 0, 3, 0, 0개    |
|  1, 3, 0, 0 개   |    0, 2, 0, 0, 0개    |

=> 400이 없을 때는 아래 항목들로 윗항목을 만들 수 있으나, 400이 생기면서 400으로 500을 못만들기 때문에 그리디가 적용안됨.










